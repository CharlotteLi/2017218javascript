### this
- 当函数被调用的时候，点前面是谁，this就是谁；
- 自执行函数的this永远是window
- 回调函数的this一般都是window；
- 当元素身上的事件被触发的时候，会执行一个函数，函数中的this指向当前这个元素；
### 返回值：
- 函数的返回值是return
- return的作用：
    + 函数的返回值
    + 阻断程序的执行
- undefined出现的几种情况
    + 定义了形参但没有赋值，拿到的就是undefined；
    + 函数中没有return，拿的返回值是undefined；
    + 函数中写了return但没有赋值，拿到的也是undefined；
    + 对象上的属性不存在的时候，拿到的undefined；
=====================================
### 面向对象
- 对象两大特征：属性  和 方法；
- 面向对象(oop,oo)思想的特点：
    + 封装：对于同一个功能，只需要封装一次，以后再使用的时候，只需要调用即可，无需重写；
    低耦合高内聚；
    + 继承：子类可以继承父类的属性和方法；
    + 多态：重载 和 重写；
    重载：JS上没有严格意义上的重载；但有类似重载的功能，就是传不同的参数，有不同的返回值；
    重写：子类可以重写父类的属性和方法；
- 面向对象的设计模式：列举四种常见的设计模式：
    + 单例模式
    + 工厂模式
    + 构造函数模式
    + 原型模式
### 单例模式：
- 把同一个对象上的属性和方法，都放在同一个命名空间；
- 单例模式的本质：普通对象；
- 模块化开发：对于一个复杂的大项目，可以分配给不同的工程师同步进行开发；等项目完成的时候，合并即可；
    + 各个模块之间的相互调用：对象名.属性名
    + 本模块之间的相互调用：this.属性名；
- 缺点：造成大量冗余代码
### 工厂模式：
- 工厂模式有3步：
    + 引进原材料         创建一个空对象{}
    + 加工原材料         加工对象：给对象添加属性和方法；
    + 输出产品成         输出对象： return
- 工厂模式，为了让他张的像系统的类 new Array()
- 工厂模式和构造函数模式的区别：
    1. 在调用的时候：
        工厂模式 person()
        构造函数模式 new Person()
    2. 在函数体内
        工厂模式三步：1）创建对象 2）给对象添加属性和方法 3）返回对象
        构造函数模式只有一步：2）给对象添加属性和方法 ； 第一步和第三步系统帮做了，系统提供了一个对象叫this;
- 构造函数模式
    1.构造函数首字母一定大写
    2.构造函数中放的都是私有的属性和方法
    3.原型上放的都是共有的属性和方法；
    4.系统默认会创建一个对象，this；
    5.系统默认会返回一个对象 this;
    6.构造函数中的this，指向当前这个实例；（构造函数new给谁，this就指向谁）；
    
- 原型模式基础：
    1. 每个函数数据类型(普通函数，类)，都有一个属性，叫做prototye,prototype是个对象；
    2. prototype这个对象上，天生自带一个属性，叫做constructor，指向当前所属类；
    3. 每个对象（普通对象，实例，prototype）身上，都有一个属性，叫做__proto__,指向当前对象所属类的原型；
- 原型链：__proto__
    如果要查找 对象.属性名 比如f1.showX;
    1. 现在自己的私有作用域中查找；如果找到，那么这个属性是私有属性；
    2. 如果没找到，到当前实例所属类的原型上找(f1.__proto__),如果找到属于共有的属性或方法；
    3. 如果没找到，继续通过__proto__往上找，一直找到Object.prototype上还没有的话，undefined;
- 要形成的几个条件反射：
    1. 一看到构造函数-》存的都是私有的属性和方法
    2. 一看到prototype-》存的都是共有的属性和方法
    3. __proto__ 原型链
- 作业：
    + 整理笔记
    + 画图预解释：1）面试题 2）做完：1.讲过的题 2。word题
    
    
    
    
    
    